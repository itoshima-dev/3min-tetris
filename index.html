<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>„ÉÜ„Éà„É™„Çπ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            touch-action: none;
            /* ÈªÑÁ∑ë„Éô„Éº„Çπ„ÅÆ„Ç∞„Éü„Éë„Ç∫„É´È¢®ËÉåÊôØ */
            background-color: #eaffd0;
            background-image: 
                radial-gradient(rgba(255, 255, 255, 0.5) 20%, transparent 20%),
                radial-gradient(rgba(255, 255, 255, 0.5) 20%, transparent 20%);
            background-size: 60px 60px;
            background-position: 0 0, 30px 30px;
            color: #4a4a4a;
            font-family: 'Zen Maru Gothic', sans-serif;
            overflow: hidden; 
            height: 100vh;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        #game-canvas {
            border: 5px solid #fff;
            background-color: rgba(255, 255, 255, 0.4);
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0, 128, 0, 0.1);
            cursor: pointer;
        }
        .side-canvas {
            border: 3px solid #fff;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 8px;
        }
        .control-btn {
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            box-shadow: 0 4px 0 #7cb07c;
            transition: all 0.1s;
        }
        .control-btn:active {
            box-shadow: none;
            transform: translateY(4px);
        }
        /* È≠îÊ≥ï„Éú„Çø„É≥„ÅÆ„Éá„Ç∂„Ç§„É≥Ë™øÊï¥ */
        .magic-btn {
            box-shadow: 0 4px 0 #8b5cf6;
            background: linear-gradient(135deg, #c084fc, #9333ea);
            border: 2px solid #fff;
            animation: pulse-light 2s infinite;
        }
        @keyframes pulse-light {
            0% { filter: brightness(1); }
            50% { filter: brightness(1.1); }
            100% { filter: brightness(1); }
        }
        .magic-btn:active {
            box-shadow: none;
            transform: translateY(4px);
        }
        .quit-btn {
            box-shadow: 0 4px 0 #dc2626;
            background: #ef4444;
        }
        .score-box {
            background: rgba(255, 255, 255, 0.85);
            border: 3px solid #a8e6cf;
        }
        .overlay {
            backdrop-blur: 10px;
            background-color: rgba(255, 255, 255, 0.95);
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 20px; width: 20px;
            left: 4px; bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: #55e055; }
        input:checked + .slider:before { transform: translateX(22px); }

        @keyframes tetrisPop {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }
        .tetris-text {
            animation: tetrisPop 1.5s ease-out forwards;
            pointer-events: none;
            white-space: nowrap;
        }
    </style>
</head>
<body class="p-1">

    <!-- „Çø„Ç§„Éû„Éº -->
    <div class="mb-2 text-center w-full">
        <div class="score-box px-4 py-1 rounded-full font-bold flex items-center justify-center gap-3 text-green-700 shadow-sm mx-auto max-w-fit">
            <span class="text-sm">‚è∞ „ÅÆ„Åì„Çä</span>
            <span id="timer" class="text-3xl font-mono text-red-500">03:00</span>
        </div>
    </div>

    <div class="flex items-center justify-center gap-3 w-full">
        <!-- „Ç≤„Éº„É†„Ç®„É™„Ç¢ -->
        <div class="relative">
            <canvas id="game-canvas" width="200" height="360"></canvas>
            
            <div id="tetris-effect" class="hidden absolute inset-0 flex items-center justify-center pointer-events-none z-30">
                <!-- ÊñáÂ≠ó„Çí„Äå„Éë„Éº„Éï„Çß„ÇØ„Éà„Äç„Å´Â§âÊõ¥ -->
                <span class="tetris-text text-4xl font-black text-pink-500 drop-shadow-[0_0_15px_rgba(255,255,255,1)] italic text-center">‚ú®„Éë„Éº„Éï„Çß„ÇØ„Éà‚ú®</span>
            </div>

            <!-- „Çπ„Çø„Éº„ÉàÁîªÈù¢ -->
            <div id="start-screen" class="absolute inset-0 overlay rounded-[12px] flex flex-col items-center justify-center text-center p-5 z-20">
                <div class="text-sm leading-relaxed space-y-3 mb-4 text-left border-y-2 border-green-200 py-3 w-full mt-2">
                    <div class="flex flex-col gap-1">
                        <p class="font-bold text-green-700 text-[12px]">üíé „Çπ„Ç≥„Ç¢Ë°®</p>
                        <div class="grid grid-cols-2 gap-2">
                            <div class="bg-pink-100 rounded-lg px-2 py-1 flex justify-between items-center border border-pink-200 shadow-sm">
                                <span class="text-[10px] text-pink-600">1Âàó</span>
                                <span class="font-bold text-pink-700">10ÁÇπ</span>
                            </div>
                            <div class="bg-orange-100 rounded-lg px-2 py-1 flex justify-between items-center border border-orange-200 shadow-sm">
                                <span class="text-[10px] text-orange-600">2Âàó</span>
                                <span class="font-bold text-orange-700">30ÁÇπ</span>
                            </div>
                            <div class="bg-blue-100 rounded-lg px-2 py-1 flex justify-between items-center border border-blue-200 shadow-sm">
                                <span class="text-[10px] text-blue-600">3Âàó</span>
                                <span class="font-bold text-blue-700">60ÁÇπ</span>
                            </div>
                            <div class="bg-yellow-100 rounded-lg px-2 py-1 flex justify-between items-center border border-yellow-300 shadow-sm">
                                <span class="text-[10px] text-yellow-600 font-black">4Âàó</span>
                                <span class="font-bold text-yellow-800">100ÁÇπ</span>
                            </div>
                        </div>
                    </div>

                    <div class="bg-purple-100 p-2 rounded-xl border-2 border-purple-300 shadow-sm text-center">
                        <p class="font-bold text-purple-600 mb-1 text-[13px]">ü™Ñ „Åæ„Åª„ÅÜ„ÅÆ„Éú„Çø„É≥ ü™Ñ</p>
                        <p class="text-[11px]">„Äåü™Ñ„Äç„Çí„Åä„Åô„Å®„ÄÅ„Åô„Åç„Åæ„Çí 7„Å§<br>ËôπËâ≤„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„Åß„ÅÜ„ÇÅ„Çã„ÇàÔºÅ</p>
                    </div>
                    
                    <div class="flex items-center justify-between mt-1 bg-white/50 p-2 rounded-xl border border-green-100">
                        <span class="font-bold text-sm">„Åæ„Åª„ÅÜ„Çí„Å§„Åã„ÅÜ</span>
                        <label class="switch">
                            <input type="checkbox" id="special-toggle" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>
                <button onclick="startGame()" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-10 rounded-full shadow-lg transition animate-bounce text-xl whitespace-nowrap">
                    „Çπ„Çø„Éº„ÉàÔºÅ
                </button>
            </div>

            <!-- „Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºÁîªÈù¢ -->
            <div id="game-over" class="hidden absolute inset-0 overlay rounded-[12px] flex flex-col items-center justify-center text-center z-20 p-4">
                <h2 id="game-over-title" class="text-3xl font-bold text-green-600 mb-3">„Åä„Åó„Åæ„ÅÑ„Å£üß∏</h2>
                <div class="mb-5">
                    <p class="text-lg text-gray-500">„Åï„ÅÑ„Åó„ÇÖ„ÅÜ„Çπ„Ç≥„Ç¢</p>
                    <p class="text-5xl font-mono font-bold text-green-600 text-center"><span id="final-score">0</span>ÁÇπ</p>
                </div>
                <button onclick="resetGame()" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-full shadow-lg transition text-xl whitespace-nowrap">
                    „ÇÇ„ÅÜ„ÅÑ„Å°„Å©ÈÅä„Å∂
                </button>
            </div>

            <!-- „Éù„Éº„Ç∫ÁîªÈù¢ -->
            <div id="pause-screen" class="hidden absolute inset-0 overlay rounded-[12px] flex flex-col items-center justify-center text-center z-20">
                <h2 class="text-3xl font-bold text-green-600 mb-6">„Åä„ÇÑ„Åô„Åø‰∏≠...üí§</h2>
                <button onclick="togglePause()" class="bg-blue-400 hover:bg-blue-500 text-white font-bold py-3 px-10 rounded-full shadow-lg transition text-xl whitespace-nowrap">
                    „Å§„Å•„Åç„Åã„Çâ
                </button>
            </div>

            <!-- ÁµÇ‰∫ÜÁ¢∫Ë™ç„ÉÄ„Ç§„Ç¢„É≠„Ç∞ -->
            <div id="quit-confirm" class="hidden absolute inset-0 overlay rounded-[12px] flex flex-col items-center justify-center text-center z-40 p-4">
                <h2 class="text-2xl font-bold text-red-500 mb-4">„Åó„ÇÖ„ÅÜ„Çä„Çá„ÅÜ„Åô„ÇãÔºü</h2>
                <p class="text-sm text-gray-600 mb-6">„Åª„Çì„Å®„ÅÜ„Å´ „ÇÑ„ÇÅ„Å°„ÇÉ„ÅÜÔºü</p>
                <div class="flex gap-4 justify-center">
                    <button onclick="confirmQuit()" class="bg-red-500 text-white font-bold py-2 px-6 rounded-full shadow-lg">„ÇÑ„ÇÅ„Çã</button>
                    <button onclick="cancelQuit()" class="bg-gray-400 text-white font-bold py-2 px-6 rounded-full shadow-lg">„Å§„Å•„Åë„Çã</button>
                </div>
            </div>
        </div>

        <!-- „Çµ„Ç§„Éâ„Éê„Éº -->
        <div class="flex flex-col gap-2">
            <div class="score-box px-3 py-1 rounded-xl text-center shadow-sm">
                <p class="text-[11px] font-bold text-green-600">„Çπ„Ç≥„Ç¢</p>
                <p class="text-lg font-mono font-bold text-green-500 whitespace-nowrap"><span id="score">0</span>ÁÇπ</p>
            </div>
            <div id="magic-count-box" class="score-box px-3 py-1 rounded-xl text-center shadow-sm">
                <p class="text-[11px] font-bold text-purple-600">„Åæ„Åª„ÅÜ</p>
                <p id="magic-charges" class="text-xl font-bold text-purple-500">3</p>
            </div>
            <div class="score-box p-1 rounded-xl text-center shadow-sm">
                <p class="text-[11px] font-bold text-green-600 mb-1 text-[9px]">„Å§„Åé</p>
                <canvas id="next-1" width="50" height="50" class="side-canvas mx-auto"></canvas>
            </div>
            <div class="score-box p-1 rounded-xl text-center shadow-sm">
                <p class="text-[11px] font-bold text-green-600 mb-1 text-[9px]">„Åù„ÅÆ„Å§„Åé</p>
                <canvas id="next-2" width="50" height="50" class="side-canvas mx-auto"></canvas>
            </div>
        </div>
    </div>

    <!-- „Ç≥„É≥„Éà„É≠„Éº„É©„Éº -->
    <div class="mt-4 flex flex-col items-center gap-3 w-full max-w-sm px-2">
        <!-- ‰∏äÊÆµ„Éú„Çø„É≥ -->
        <div class="flex gap-6 items-center">
            <button id="btn-rotate" class="control-btn bg-yellow-400 text-white w-12 h-12 rounded-full flex items-center justify-center text-xl">‚Üª</button>
            <button id="btn-pause" onclick="togglePause()" class="control-btn bg-blue-300 text-white w-12 h-12 rounded-full flex items-center justify-center text-xl">‚è∏</button>
            <button id="btn-quit" onclick="manualEndGame()" class="control-btn quit-btn text-white w-12 h-12 rounded-full flex items-center justify-center text-xl">‚èπ</button>
        </div>
        
        <!-- ‰∏ãÊÆµ„Éú„Çø„É≥Ôºö4„Å§„ÇíÂêå„ÅòÈ´ò„Åï„Å´‰∏¶„Åπ„Çã -->
        <div class="grid grid-cols-4 gap-2 w-full max-w-[310px]">
            <button id="btn-left" class="control-btn bg-green-500 text-white h-14 rounded-2xl flex items-center justify-center text-3xl">‚Üê</button>
            <button id="btn-down" class="control-btn bg-green-500 text-white h-14 rounded-2xl flex items-center justify-center text-3xl">‚Üì</button>
            <button id="btn-right" class="control-btn bg-green-500 text-white h-14 rounded-2xl flex items-center justify-center text-3xl">‚Üí</button>
            <!-- È≠îÊ≥ï„Éú„Çø„É≥„ÅÆÈ´ò„Åï„Çí h-14 „Å´Áµ±‰∏Ä„Åó„ÄÅ‰ªñ„ÅÆ„Éú„Çø„É≥„Å®‰ΩçÁΩÆ„ÇíÂêà„Çè„Åõ„Åæ„Åó„Åü -->
            <button id="btn-magic" class="control-btn magic-btn text-white h-14 rounded-2xl flex flex-col items-center justify-center">
                <span class="text-xl">ü™Ñ</span>
                <span class="text-[8px] font-bold">„Åæ„Åª„ÅÜ</span>
            </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const context = canvas.getContext('2d');
        const nextCtx1 = document.getElementById('next-1').getContext('2d');
        const nextCtx2 = document.getElementById('next-2').getContext('2d');
        const scoreElement = document.getElementById('score');
        const timerElement = document.getElementById('timer');
        const magicChargesElement = document.getElementById('magic-charges');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over');
        const gameOverTitle = document.getElementById('game-over-title');
        const pauseScreen = document.getElementById('pause-screen');
        const quitConfirm = document.getElementById('quit-confirm');
        const finalScoreElement = document.getElementById('final-score');
        const specialToggle = document.getElementById('special-toggle');
        const btnMagic = document.getElementById('btn-magic');
        const tetrisEffect = document.getElementById('tetris-effect');

        const GRID_SIZE = 20; 
        context.scale(GRID_SIZE, GRID_SIZE);
        nextCtx1.scale(12.5, 12.5);
        nextCtx2.scale(12.5, 12.5);

        const colors = [
            null,
            '#ff5e78', // I
            '#ff9642', // L
            '#3ddad7', // J
            '#ffdf40', // O
            '#55e055', // Z
            '#ff85e4', // S
            '#6a9dff', // T
            '#ffffff', // È≠îÊ≥ï„Éû„Çπ
        ];

        function createPiece(type) {
            if (type === 'I') return [[0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]];
            if (type === 'L') return [[0, 2, 0], [0, 2, 0], [0, 2, 2]];
            if (type === 'J') return [[0, 3, 0], [0, 3, 0], [3, 3, 0]];
            if (type === 'O') return [[4, 4], [4, 4]];
            if (type === 'Z') return [[5, 5, 0], [0, 5, 5], [0, 0, 0]];
            if (type === 'S') return [[0, 6, 6], [6, 6, 0], [0, 0, 0]];
            if (type === 'T') return [[0, 7, 0], [7, 7, 7], [0, 0, 0]];
        }

        const arena = Array.from({length: 18}, () => new Array(10).fill(0));

        const player = {
            pos: {x: 0, y: 0},
            matrix: null,
            score: 0,
            queue: [],
            magicCharges: 3,
            rotateFlash: 0 
        };

        let clearingRows = [];
        let clearAnimCounter = 0;
        let tetrisFlashCounter = 0;
        let globalTick = 0;

        let isLeftActive = false;
        let isRightActive = false;
        let moveTimer = 0;
        const MOVE_DELAY = 180; 
        const MOVE_INTERVAL = 60; 

        function draw() {
            globalTick++;
            context.fillStyle = 'rgba(255, 255, 255, 0.4)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            if (tetrisFlashCounter > 0) {
                tetrisFlashCounter--;
                const hue = (globalTick * 20) % 360;
                context.fillStyle = `hsla(${hue}, 100%, 80%, 0.3)`;
                context.fillRect(0, 0, canvas.width, canvas.height);
            }

            drawMatrix(context, arena, {x: 0, y: 0});
            
            if (player.matrix && isStarted && !isPaused && !isGameOver) {
                const ghostY = getGhostPosition();
                drawMatrix(context, player.matrix, {x: player.pos.x, y: ghostY}, true);
            }

            drawMatrix(context, player.matrix, player.pos);
            
            if (clearingRows.length > 0) {
                const alpha = clearAnimCounter / 10;
                context.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                clearingRows.forEach(y => {
                    context.fillRect(0, y, 10, 1);
                });
            }
            drawNext();
            
            if (player.rotateFlash > 0) player.rotateFlash--;
        }

        function drawMatrix(ctx, matrix, offset, isGhost = false) {
            if (!matrix) return;
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        const px = x + offset.x;
                        const py = y + offset.y;
                        
                        if (isGhost) {
                            ctx.strokeStyle = colors[value];
                            ctx.lineWidth = 0.05;
                            ctx.setLineDash([0.2, 0.1]);
                            ctx.strokeRect(px + 0.1, py + 0.1, 0.8, 0.8);
                            ctx.setLineDash([]);
                            ctx.fillStyle = colors[value] + '22';
                            ctx.fillRect(px + 0.1, py + 0.1, 0.8, 0.8);
                            return;
                        }

                        if (value === 9) {
                            const hue = (globalTick * 8 + px * 30 + py * 30) % 360;
                            ctx.fillStyle = `hsla(${hue}, 90%, 75%, 1)`;
                            ctx.beginPath();
                            ctx.roundRect(px + 0.05, py + 0.05, 0.9, 0.9, 0.4);
                            ctx.fill();
                            ctx.fillStyle = 'white';
                            if (Math.sin(globalTick * 0.3 + px) > 0) {
                                ctx.fillRect(px + 0.1, py + 0.1, 0.15, 0.15);
                                ctx.fillRect(px + 0.7, py + 0.7, 0.15, 0.15);
                            }
                            ctx.strokeStyle = 'white';
                            ctx.lineWidth = 0.05;
                            ctx.stroke();
                        } else {
                            const grad = ctx.createRadialGradient(px+0.5, py+0.5, 0.1, px+0.5, py+0.5, 0.6);
                            grad.addColorStop(0, colors[value]);
                            grad.addColorStop(1, lightenColor(colors[value], 20));
                            ctx.fillStyle = grad;
                            if (!isGhost && player.rotateFlash > 0) {
                                ctx.fillStyle = '#ffffffaa';
                            }
                            ctx.beginPath();
                            ctx.roundRect(px + 0.05, py + 0.05, 0.9, 0.9, 0.25);
                            ctx.fill();
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                            ctx.beginPath();
                            ctx.ellipse(px + 0.35, py + 0.3, 0.15, 0.1, 0, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                });
            });
        }

        function getGhostPosition() {
            let y = player.pos.y;
            while (!collide(arena, {pos: {x: player.pos.x, y: y + 1}, matrix: player.matrix})) {
                y++;
            }
            return y;
        }

        function lightenColor(hex, percent) {
            const num = parseInt(hex.replace('#', ''), 16),
                amt = Math.round(2.55 * percent),
                R = (num >> 16) + amt,
                G = (num >> 8 & 0x00FF) + amt,
                B = (num & 0x0000FF) + amt;
            return "#" + (0x1000000 + (R < 255 ? R < 0 ? 0 : R : 255) * 0x10000 + (G < 255 ? G < 0 ? 0 : G : 255) * 0x100 + (B < 255 ? B < 0 ? 0 : B : 255)).toString(16).slice(1);
        }

        function drawNext() {
            [nextCtx1, nextCtx2].forEach((ctx, i) => {
                ctx.clearRect(0, 0, 4, 4);
                if (player.queue[i]) {
                    const matrix = player.queue[i];
                    const offX = (4 - matrix[0].length) / 2;
                    const offY = (4 - matrix.length) / 2;
                    drawMatrix(ctx, matrix, {x: offX, y: offY});
                }
            });
        }

        function collide(arena, p) {
            const [m, o] = [p.matrix, p.pos];
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 &&
                       (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
                        return true;
                    }
                }
            }
            return false;
        }

        function useMagic() {
            if (!isStarted || isGameOver || isPaused || player.magicCharges <= 0) return;
            let gaps = [];
            for (let y = arena.length - 1; y >= 0; y--) {
                for (let x = 0; x < arena[y].length; x++) {
                    if (arena[y][x] === 0) {
                        let hasBlockAbove = false;
                        for (let up = y - 1; up >= 0; up--) {
                            if (arena[up][x] !== 0) {
                                hasBlockAbove = true;
                                break;
                            }
                        }
                        if (hasBlockAbove || y === arena.length - 1) gaps.push({x, y});
                    }
                }
            }
            if (gaps.length === 0) return;
            gaps.sort(() => Math.random() - 0.5);
            const count = Math.min(gaps.length, 7);
            for (let i = 0; i < count; i++) {
                const {x, y} = gaps[i];
                arena[y][x] = 9;
            }
            player.magicCharges--;
            updateMagicDisplay();
            // È≠îÊ≥ï‰ΩøÁî®Âæå„Å´„É©„Ç§„É≥Ê∂àÂéª„ÉÅ„Çß„ÉÉ„ÇØ„Å®„Çπ„Ç≥„Ç¢Âä†ÁÆó„ÇíÁ¢∫ÂÆü„Å´ÂÆüË°å
            arenaSweep();
        }

        function merge(arena, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) arena[y + player.pos.y][x + player.pos.x] = value;
                });
            });
        }

        function rotate(matrix, dir) {
            for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                }
            }
            if (dir > 0) matrix.forEach(row => row.reverse());
            else matrix.reverse();
        }

        function arenaSweep() {
            let rowCount = 0;
            let tempClearingRows = [];
            outer: for (let y = arena.length - 1; y > 0; --y) {
                for (let x = 0; x < arena[y].length; ++x) {
                    if (arena[y][x] === 0) continue outer;
                }
                tempClearingRows.push(y);
                rowCount++;
            }
            
            if (rowCount > 0) {
                clearingRows = tempClearingRows;
                clearAnimCounter = 10;
                if (rowCount === 4) {
                    tetrisFlashCounter = 30;
                    tetrisEffect.classList.remove('hidden');
                    setTimeout(() => tetrisEffect.classList.add('hidden'), 1500);
                }
                const lineScores = { 1: 10, 2: 30, 3: 60, 4: 100 };
                player.score += lineScores[rowCount] || (rowCount * 10);
                updateScore();
            }
        }

        function finishLineClear() {
            clearingRows.sort((a,b) => a-b).forEach(y => {
                const row = arena.splice(y, 1)[0].fill(0);
                arena.unshift(row);
            });
            clearingRows = [];
        }

        function playerDrop() {
            if (isGameOver || isPaused || !isStarted || clearingRows.length > 0) return;
            player.pos.y++;
            if (collide(arena, player)) {
                player.pos.y--;
                merge(arena, player);
                playerReset();
                arenaSweep();
                updateScore();
            }
            dropCounter = 0;
        }

        function playerMove(dir) {
            if (isGameOver || isPaused || !isStarted || clearingRows.length > 0) return;
            player.pos.x += dir;
            if (collide(arena, player)) {
                player.pos.x -= dir;
                return false;
            }
            return true;
        }

        function playerRotate(dir) {
            if (isGameOver || isPaused || !isStarted || clearingRows.length > 0) return;
            const pos = player.pos.x;
            let offset = 1;
            rotate(player.matrix, dir);
            while (collide(arena, player)) {
                player.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > player.matrix[0].length) {
                    rotate(player.matrix, -dir);
                    player.pos.x = pos;
                    return;
                }
            }
            player.rotateFlash = 3; 
        }

        function playerReset() {
            const pieces = 'ILJOTSZ';
            while (player.queue.length < 3) player.queue.push(createPiece(pieces[pieces.length * Math.random() | 0]));
            player.matrix = player.queue.shift();
            player.queue.push(createPiece(pieces[pieces.length * Math.random() | 0]));
            player.pos.y = 0;
            player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
            if (collide(arena, player)) endGame("„Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºÔºÅ");
        }

        function updateScore() {
            scoreElement.innerText = player.score;
        }

        function updateMagicDisplay() {
            magicChargesElement.innerText = player.magicCharges;
            btnMagic.disabled = (player.magicCharges <= 0 || !specialToggle.checked);
            document.getElementById('magic-count-box').style.display = specialToggle.checked ? 'block' : 'none';
        }

        function updateTimerDisplay() {
            const mins = Math.floor(timeLeft / 60);
            const secs = timeLeft % 60;
            timerElement.innerText = `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            if (timeLeft <= 10) timerElement.classList.add('animate-pulse');
            else timerElement.classList.remove('animate-pulse');
        }

        function togglePause() {
            if (isGameOver || !isStarted) return;
            isPaused = !isPaused;
            if (isPaused) {
                pauseScreen.classList.remove('hidden');
                clearInterval(timerInterval);
            } else {
                pauseScreen.classList.add('hidden');
                lastTime = performance.now();
                startTimer();
                requestAnimationFrame(update);
            }
        }

        function manualEndGame() {
            if (!isStarted) return;
            if (isGameOver) {
                resetGameToHome();
                return;
            }
            if (!isPaused) togglePause();
            quitConfirm.classList.remove('hidden');
        }

        function confirmQuit() {
            quitConfirm.classList.add('hidden');
            pauseScreen.classList.add('hidden');
            endGame("„Åó„ÇÖ„ÅÜ„Çä„Çá„ÅÜ„Åó„Åæ„Åó„ÅüÔºÅ");
        }

        function cancelQuit() {
            quitConfirm.classList.add('hidden');
            togglePause();
        }

        function startTimer() {
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (timeLeft > 0) {
                    timeLeft--;
                    updateTimerDisplay();
                } else {
                    endGame("„Çø„Ç§„É†„Ç¢„ÉÉ„ÉóÔºÅ");
                }
            }, 1000);
        }

        function endGame(title) {
            isGameOver = true;
            clearInterval(timerInterval);
            gameOverTitle.innerText = title;
            finalScoreElement.innerText = player.score;
            gameOverScreen.classList.remove('hidden');
            draw();
        }

        function startGame() {
            isStarted = true;
            startScreen.classList.add('hidden');
            player.magicCharges = specialToggle.checked ? 3 : 0;
            btnMagic.style.display = specialToggle.checked ? 'flex' : 'none';
            updateMagicDisplay();
            playerReset();
            lastTime = performance.now();
            startTimer();
            requestAnimationFrame(update);
        }

        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;
        let isGameOver = false;
        let isPaused = false;
        let isStarted = false;
        let isDownActive = false;
        let timeLeft = 180;
        let timerInterval = null;

        function update(time = 0) {
            if (isGameOver || isPaused || !isStarted) return;
            
            const deltaTime = time - lastTime;
            lastTime = time;

            if (isLeftActive || isRightActive) {
                moveTimer += deltaTime;
                if (moveTimer > MOVE_DELAY) {
                    if (moveTimer > MOVE_DELAY + MOVE_INTERVAL) {
                        playerMove(isLeftActive ? -1 : 1);
                        moveTimer = MOVE_DELAY;
                    }
                }
            } else {
                moveTimer = 0;
            }

            if (clearingRows.length > 0) {
                clearAnimCounter--;
                if (clearAnimCounter <= 0) finishLineClear();
            } else {
                dropCounter += deltaTime;
                const currentInterval = isDownActive ? dropInterval / 8 : dropInterval;
                if (dropCounter > currentInterval) playerDrop();
            }
            draw();
            requestAnimationFrame(update);
        }

        function resetGameToHome() {
            arena.forEach(row => row.fill(0));
            player.score = 0;
            player.queue = [];
            player.magicCharges = 3;
            timeLeft = 180;
            isGameOver = false;
            isPaused = false;
            isStarted = false;
            isDownActive = false;
            isLeftActive = false;
            isRightActive = false;
            clearingRows = [];
            gameOverScreen.classList.add('hidden');
            pauseScreen.classList.add('hidden');
            quitConfirm.classList.add('hidden');
            startScreen.classList.remove('hidden');
            updateTimerDisplay();
            updateScore();
            updateMagicDisplay();
            clearInterval(timerInterval);
            draw();
        }

        document.addEventListener('keydown', event => {
            if ([32, 37, 38, 39, 40].includes(event.keyCode)) event.preventDefault();
            if (isGameOver || !isStarted || isPaused || clearingRows.length > 0) return;
            
            if (event.keyCode === 37) { 
                if (!isLeftActive) {
                    playerMove(-1);
                    isLeftActive = true;
                    moveTimer = 0;
                }
            } else if (event.keyCode === 39) { 
                if (!isRightActive) {
                    playerMove(1);
                    isRightActive = true;
                    moveTimer = 0;
                }
            } else if (event.keyCode === 40) { 
                isDownActive = true;
            } else if (event.keyCode === 32) { 
                playerRotate(1);
            }
        });

        document.addEventListener('keyup', event => {
            if (event.keyCode === 37) isLeftActive = false;
            if (event.keyCode === 39) isRightActive = false;
            if (event.keyCode === 40) isDownActive = false;
        });

        const setupMoveBtn = (id, dir) => {
            const btn = document.getElementById(id);
            const start = (e) => { 
                e.preventDefault(); 
                if (dir === -1) { isLeftActive = true; isRightActive = false; }
                else { isRightActive = true; isLeftActive = false; }
                playerMove(dir);
                moveTimer = 0;
            };
            const stop = (e) => { 
                e.preventDefault(); 
                if (dir === -1) isLeftActive = false;
                else isRightActive = false;
            };
            btn.addEventListener('touchstart', start);
            btn.addEventListener('mousedown', start);
            btn.addEventListener('touchend', stop);
            btn.addEventListener('mouseup', stop);
            btn.addEventListener('mouseleave', stop);
        };

        const setupSimpleBtn = (id, onDown, onUp) => {
            const btn = document.getElementById(id);
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); onDown(); });
            btn.addEventListener('mousedown', (e) => { e.preventDefault(); onDown(); });
            if (onUp) {
                btn.addEventListener('touchend', (e) => { e.preventDefault(); onUp(); });
                btn.addEventListener('mouseup', (e) => { e.preventDefault(); onUp(); });
                btn.addEventListener('mouseleave', (e) => { e.preventDefault(); onUp(); });
            }
        };

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (isStarted && !isPaused && !isGameOver) playerRotate(1);
        });
        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (isStarted && !isPaused && !isGameOver) playerRotate(1);
        });

        setupMoveBtn('btn-left', -1);
        setupMoveBtn('btn-right', 1);
        setupSimpleBtn('btn-down', () => { isDownActive = true; }, () => { isDownActive = false; });
        setupSimpleBtn('btn-rotate', () => playerRotate(1));
        setupSimpleBtn('btn-magic', () => useMagic());

        function resetGame() {
            resetGameToHome();
            startGame();
        }

        updateScore();
        updateTimerDisplay();
        updateMagicDisplay();
        draw();
    </script>
</body>
</html>
