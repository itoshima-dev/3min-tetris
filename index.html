<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>„ÉÜ„Éà„É™„Çπ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #eaffd0;
        }
        body {
            touch-action: none;
            background-color: var(--bg-color);
            background-image: 
                radial-gradient(rgba(255, 255, 255, 0.5) 20%, transparent 20%),
                radial-gradient(rgba(255, 255, 255, 0.5) 20%, transparent 20%);
            background-size: 60px 60px;
            background-position: 0 0, 30px 30px;
            color: #4a4a4a;
            font-family: 'Zen Maru Gothic', sans-serif;
            overflow: hidden; 
            height: 100vh;
            height: 100dvh;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* ÁîªÈù¢ÂÖ®‰Ωì„ÇíÁÆ°ÁêÜ„Åô„Çã„Ç≥„É≥„ÉÜ„Éä */
        .main-wrapper {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            max-width: 500px; /* PC„ÅßË¶ã„Å¶„ÇÇÂ∫É„Åå„Çä„Åô„Åé„Å™„ÅÑ„Çà„ÅÜ„Å´ */
            padding: 10px;
            box-sizing: border-box;
        }

        /* „Éò„ÉÉ„ÉÄ„ÉºÈÉ®ÂàÜ */
        .header {
            flex-shrink: 0;
            margin-bottom: 8px;
        }

        /* „Ç≤„Éº„É†„Ç®„É™„Ç¢Ôºà„Ç≠„É£„É≥„Éê„Çπ„Å®„Çµ„Ç§„Éâ„Éê„ÉºÔºâ */
        .game-area {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            min-height: 0; /* flexÂÜÖ„ÅßÁ∏ÆÂ∞è„Åß„Åç„Çã„Çà„ÅÜ„Å´ */
            overflow: hidden;
        }

        /* „Ç≠„É£„É≥„Éê„Çπ„ÅÆË¶™ */
        .canvas-container {
            position: relative;
            height: 100%;
            display: flex;
            align-items: center;
        }

        #game-canvas {
            border: 5px solid #fff;
            background-color: rgba(255, 255, 255, 0.4);
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0, 128, 0, 0.1);
            max-height: 100%; /* Ë¶™„ÅÆÈ´ò„Åï„Å´Âêà„Çè„Åõ„Çã */
            max-width: 100%;
            width: auto;
            height: auto;
            aspect-ratio: 200 / 360;
            cursor: pointer;
        }

        /* „Çµ„Ç§„Éâ„Éê„Éº */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 6px;
            width: 70px;
            flex-shrink: 0;
        }

        .side-canvas {
            border: 2px solid #fff;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            width: 100%;
            aspect-ratio: 1 / 1;
        }

        /* „Ç≥„É≥„Éà„É≠„Éº„É©„ÉºÈÉ®ÂàÜ */
        .controls {
            flex-shrink: 0;
            margin-top: 10px;
            padding-bottom: 5px;
        }

        .control-btn {
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            box-shadow: 0 4px 0 #7cb07c;
            transition: all 0.1s;
        }
        .control-btn:active {
            box-shadow: none;
            transform: translateY(4px);
        }

        .magic-btn {
            box-shadow: 0 4px 0 #8b5cf6;
            background: linear-gradient(135deg, #c084fc, #9333ea);
        }

        .quit-btn {
            box-shadow: 0 4px 0 #dc2626;
            background: #ef4444;
        }

        .score-box {
            background: rgba(255, 255, 255, 0.85);
            border: 2px solid #a8e6cf;
        }

        .overlay {
            backdrop-blur: 10px;
            background-color: rgba(255, 255, 255, 0.95);
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 22px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 22px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px; width: 16px;
            left: 3px; bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: #55e055; }
        input:checked + .slider:before { transform: translateX(18px); }

        @keyframes tetrisPop {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }
        .tetris-text {
            animation: tetrisPop 1.5s ease-out forwards;
            pointer-events: none;
            white-space: nowrap;
        }
    </style>
</head>
<body>

    <div class="main-wrapper">
        <!-- 1. „Éò„ÉÉ„ÉÄ„Éº -->
        <div class="header text-center">
            <div class="score-box px-4 py-1 rounded-full font-bold flex items-center justify-center gap-3 text-green-700 shadow-sm mx-auto max-w-fit">
                <span class="text-xs">‚è∞ „ÅÆ„Åì„Çä</span>
                <span id="timer" class="text-2xl font-mono text-red-500">03:00</span>
            </div>
        </div>

        <!-- 2. „Ç≤„Éº„É†„Ç®„É™„Ç¢ -->
        <div class="game-area">
            <!-- „É°„Ç§„É≥ -->
            <div class="canvas-container">
                <canvas id="game-canvas" width="200" height="360"></canvas>
                
                <div id="tetris-effect" class="hidden absolute inset-0 flex items-center justify-center pointer-events-none z-30">
                    <span class="tetris-text text-4xl font-black text-pink-500 drop-shadow-[0_0_15px_rgba(255,255,255,1)] italic text-center">‚ú®„Éë„Éº„Éï„Çß„ÇØ„Éà‚ú®</span>
                </div>

                <!-- ÂêÑÁ®ÆÁîªÈù¢„Ç™„Éº„Éê„Éº„É¨„Ç§ -->
                <div id="start-screen" class="absolute inset-0 overlay rounded-[12px] flex flex-col items-center justify-center text-center p-4 z-20">
                    <div class="text-[10px] leading-relaxed space-y-2 mb-4 text-left border-y-2 border-green-200 py-3 w-full">
                        <div class="flex flex-col gap-1">
                            <p class="font-bold text-green-700 text-[10px]">üíé „Çπ„Ç≥„Ç¢Ë°®</p>
                            <div class="grid grid-cols-2 gap-1.5">
                                <div class="bg-pink-100 rounded px-1.5 py-0.5 flex justify-between items-center border border-pink-200">
                                    <span class="text-[8px] text-pink-600">1Âàó</span><span class="font-bold text-[10px] text-pink-700">10ÁÇπ</span>
                                </div>
                                <div class="bg-orange-100 rounded px-1.5 py-0.5 flex justify-between items-center border border-orange-200">
                                    <span class="text-[8px] text-orange-600">2Âàó</span><span class="font-bold text-[10px] text-orange-700">30ÁÇπ</span>
                                </div>
                                <div class="bg-blue-100 rounded px-1.5 py-0.5 flex justify-between items-center border border-blue-200">
                                    <span class="text-[8px] text-blue-600">3Âàó</span><span class="font-bold text-[10px] text-blue-700">60ÁÇπ</span>
                                </div>
                                <div class="bg-yellow-100 rounded px-1.5 py-0.5 flex justify-between items-center border border-yellow-300">
                                    <span class="text-[8px] font-black">4Âàó</span><span class="font-bold text-[10px] text-yellow-800">100ÁÇπ</span>
                                </div>
                            </div>
                        </div>
                        <div class="bg-purple-100 p-2 rounded-lg border-2 border-purple-300 text-center">
                            <p class="font-bold text-purple-600 mb-0.5 text-[11px]">ü™Ñ „Åæ„Åª„ÅÜ„ÅÆ„Éú„Çø„É≥ ü™Ñ</p>
                            <p class="text-[9px]">ËôπËâ≤„Éñ„É≠„ÉÉ„ÇØ„Åß „Åô„Åç„Åæ„Çí„ÅÜ„ÇÅ„Çã„ÇàÔºÅ</p>
                        </div>
                        <div class="flex items-center justify-between mt-1 bg-white/50 p-1.5 rounded-lg border border-green-100">
                            <span class="font-bold text-[10px]">„Åæ„Åª„ÅÜ„Çí„Å§„Åã„ÅÜ</span>
                            <label class="switch">
                                <input type="checkbox" id="special-toggle" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    <button onclick="startGame()" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2.5 px-8 rounded-full shadow-lg transition animate-bounce text-lg whitespace-nowrap">
                        „Çπ„Çø„Éº„ÉàÔºÅ
                    </button>
                </div>

                <div id="game-over" class="hidden absolute inset-0 overlay rounded-[12px] flex flex-col items-center justify-center text-center z-20 p-4">
                    <h2 class="text-2xl font-bold text-green-600 mb-2">„Åä„Åó„Åæ„ÅÑ„Å£üß∏</h2>
                    <div class="mb-4">
                        <p class="text-sm text-gray-500">„Åï„ÅÑ„Åó„ÇÖ„ÅÜ„Çπ„Ç≥„Ç¢</p>
                        <p class="text-4xl font-mono font-bold text-green-600"><span id="final-score">0</span>ÁÇπ</p>
                    </div>
                    <button onclick="resetGame()" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-8 rounded-full shadow-lg text-lg whitespace-nowrap">
                        „ÇÇ„ÅÜ„ÅÑ„Å°„Å©ÈÅä„Å∂
                    </button>
                </div>

                <div id="pause-screen" class="hidden absolute inset-0 overlay rounded-[12px] flex flex-col items-center justify-center text-center z-20 p-4">
                    <h2 class="text-2xl font-bold text-green-600 mb-6">„Åä„ÇÑ„Åô„Åø‰∏≠...üí§</h2>
                    <button onclick="togglePause()" class="bg-blue-400 hover:bg-blue-500 text-white font-bold py-3 px-8 rounded-full shadow-lg text-lg whitespace-nowrap">
                        „Å§„Å•„Åç„Åã„Çâ
                    </button>
                </div>

                <div id="quit-confirm" class="hidden absolute inset-0 overlay rounded-[12px] flex flex-col items-center justify-center text-center z-40 p-4">
                    <h2 class="text-xl font-bold text-red-500 mb-4">„Åó„ÇÖ„ÅÜ„Çä„Çá„ÅÜ„Åô„ÇãÔºü</h2>
                    <div class="flex gap-4 justify-center">
                        <button onclick="confirmQuit()" class="bg-red-500 text-white font-bold py-2 px-6 rounded-full text-sm">„ÇÑ„ÇÅ„Çã</button>
                        <button onclick="cancelQuit()" class="bg-gray-400 text-white font-bold py-2 px-6 rounded-full text-sm">„Å§„Å•„Åë„Çã</button>
                    </div>
                </div>
            </div>

            <!-- „Çµ„Ç§„Éâ„Éê„Éº -->
            <div class="sidebar">
                <div class="score-box p-1.5 rounded-xl text-center shadow-sm">
                    <p class="text-[9px] font-bold text-green-600 leading-none mb-1">„Çπ„Ç≥„Ç¢</p>
                    <p class="text-xs font-mono font-bold text-green-500"><span id="score">0</span>ÁÇπ</p>
                </div>
                <div id="magic-count-box" class="score-box p-1.5 rounded-xl text-center shadow-sm">
                    <p class="text-[9px] font-bold text-purple-600 leading-none mb-1">„Åæ„Åª„ÅÜ</p>
                    <p id="magic-charges" class="text-sm font-bold text-purple-500">3</p>
                </div>
                <div class="score-box p-1.5 rounded-xl text-center shadow-sm">
                    <p class="text-[9px] font-bold text-green-600 mb-1">„Å§„Åé</p>
                    <canvas id="next-1" width="40" height="40" class="side-canvas mx-auto"></canvas>
                </div>
                <div class="score-box p-1.5 rounded-xl text-center shadow-sm">
                    <p class="text-[9px] font-bold text-green-600 mb-1">„Åù„ÅÆ„Å§„Åé</p>
                    <canvas id="next-2" width="40" height="40" class="side-canvas mx-auto"></canvas>
                </div>
            </div>
        </div>

        <!-- 3. „Ç≥„É≥„Éà„É≠„Éº„É©„Éº -->
        <div class="controls">
            <div class="flex flex-col items-center gap-2">
                <!-- „Çµ„ÉñÊìç‰Ωú -->
                <div class="flex gap-6 items-center">
                    <button id="btn-rotate" class="control-btn bg-yellow-400 text-white w-10 h-10 rounded-full flex items-center justify-center text-xl">‚Üª</button>
                    <button id="btn-pause" onclick="togglePause()" class="control-btn bg-blue-300 text-white w-10 h-10 rounded-full flex items-center justify-center text-xl">‚è∏</button>
                    <button id="btn-quit" onclick="manualEndGame()" class="control-btn quit-btn text-white w-10 h-10 rounded-full flex items-center justify-center text-xl">‚èπ</button>
                </div>
                
                <!-- „É°„Ç§„É≥Êìç‰ΩúÔºà1ÂàóÔºâ -->
                <div class="grid grid-cols-4 gap-2 w-full max-w-[320px]">
                    <button id="btn-left" class="control-btn bg-green-500 text-white h-12 rounded-xl flex items-center justify-center text-3xl">‚Üê</button>
                    <button id="btn-down" class="control-btn bg-green-500 text-white h-12 rounded-xl flex items-center justify-center text-3xl">‚Üì</button>
                    <button id="btn-right" class="control-btn bg-green-500 text-white h-12 rounded-xl flex items-center justify-center text-3xl">‚Üí</button>
                    <button id="btn-magic" class="control-btn magic-btn text-white h-12 rounded-xl flex flex-col items-center justify-center">
                        <span class="text-xl leading-none">ü™Ñ</span>
                        <span class="text-[8px] font-bold">„Åæ„Åª„ÅÜ</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const context = canvas.getContext('2d');
        const nextCtx1 = document.getElementById('next-1').getContext('2d');
        const nextCtx2 = document.getElementById('next-2').getContext('2d');
        const scoreElement = document.getElementById('score');
        const timerElement = document.getElementById('timer');
        const magicChargesElement = document.getElementById('magic-charges');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over');
        const pauseScreen = document.getElementById('pause-screen');
        const quitConfirm = document.getElementById('quit-confirm');
        const finalScoreElement = document.getElementById('final-score');
        const specialToggle = document.getElementById('special-toggle');
        const btnMagic = document.getElementById('btn-magic');
        const tetrisEffect = document.getElementById('tetris-effect');

        const GRID_SIZE = 20; 
        context.scale(GRID_SIZE, GRID_SIZE);
        nextCtx1.scale(10, 10);
        nextCtx2.scale(10, 10);

        const colors = [
            null,
            '#ff5e78', // I
            '#ff9642', // L
            '#3ddad7', // J
            '#ffdf40', // O
            '#55e055', // Z
            '#ff85e4', // S
            '#6a9dff', // T
            '#ffffff', // È≠îÊ≥ï
        ];

        function createPiece(type) {
            if (type === 'I') return [[0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]];
            if (type === 'L') return [[0, 2, 0], [0, 2, 0], [0, 2, 2]];
            if (type === 'J') return [[0, 3, 0], [0, 3, 0], [3, 3, 0]];
            if (type === 'O') return [[4, 4], [4, 4]];
            if (type === 'Z') return [[5, 5, 0], [0, 5, 5], [0, 0, 0]];
            if (type === 'S') return [[0, 6, 6], [6, 6, 0], [0, 0, 0]];
            if (type === 'T') return [[0, 7, 0], [7, 7, 7], [0, 0, 0]];
        }

        const arena = Array.from({length: 18}, () => new Array(10).fill(0));

        const player = {
            pos: {x: 0, y: 0},
            matrix: null,
            score: 0,
            queue: [],
            magicCharges: 3,
            rotateFlash: 0 
        };

        let clearingRows = [];
        let clearAnimCounter = 0;
        let tetrisFlashCounter = 0;
        let globalTick = 0;
        let isStarted = false;
        let isGameOver = false;
        let isPaused = false;
        let isLeftActive = false;
        let isRightActive = false;
        let isDownActive = false;
        let moveTimer = 0;
        const MOVE_DELAY = 180; 
        const MOVE_INTERVAL = 60; 

        function draw() {
            globalTick++;
            context.fillStyle = 'rgba(255, 255, 255, 0.4)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            if (tetrisFlashCounter > 0) {
                tetrisFlashCounter--;
                const hue = (globalTick * 20) % 360;
                context.fillStyle = `hsla(${hue}, 100%, 80%, 0.3)`;
                context.fillRect(0, 0, canvas.width, canvas.height);
            }

            drawMatrix(context, arena, {x: 0, y: 0});
            
            if (player.matrix && isStarted && !isPaused && !isGameOver) {
                const ghostY = getGhostPosition();
                drawMatrix(context, player.matrix, {x: player.pos.x, y: ghostY}, true);
            }

            drawMatrix(context, player.matrix, player.pos);
            
            if (clearingRows.length > 0) {
                const alpha = clearAnimCounter / 10;
                context.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                clearingRows.forEach(y => {
                    context.fillRect(0, y, 10, 1);
                });
            }
            drawNext();
            if (player.rotateFlash > 0) player.rotateFlash--;
        }

        function drawMatrix(ctx, matrix, offset, isGhost = false) {
            if (!matrix) return;
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        const px = x + offset.x;
                        const py = y + offset.y;
                        
                        if (isGhost) {
                            ctx.strokeStyle = colors[value];
                            ctx.lineWidth = 0.05;
                            ctx.setLineDash([0.2, 0.1]);
                            ctx.strokeRect(px + 0.1, py + 0.1, 0.8, 0.8);
                            ctx.setLineDash([]);
                            ctx.fillStyle = colors[value] + '22';
                            ctx.fillRect(px + 0.1, py + 0.1, 0.8, 0.8);
                            return;
                        }

                        if (value === 9) {
                            const hue = (globalTick * 8 + px * 30 + py * 30) % 360;
                            ctx.fillStyle = `hsla(${hue}, 90%, 75%, 1)`;
                            ctx.beginPath();
                            ctx.roundRect(px + 0.05, py + 0.05, 0.9, 0.9, 0.4);
                            ctx.fill();
                            ctx.fillStyle = 'white';
                            if (Math.sin(globalTick * 0.3 + px) > 0) {
                                ctx.fillRect(px + 0.1, py + 0.1, 0.15, 0.15);
                                ctx.fillRect(px + 0.7, py + 0.7, 0.15, 0.15);
                            }
                            ctx.strokeStyle = 'white';
                            ctx.lineWidth = 0.05;
                            ctx.stroke();
                        } else {
                            const grad = ctx.createRadialGradient(px+0.5, py+0.5, 0.1, px+0.5, py+0.5, 0.6);
                            grad.addColorStop(0, colors[value]);
                            grad.addColorStop(1, lightenColor(colors[value], 20));
                            ctx.fillStyle = grad;
                            if (!isGhost && player.rotateFlash > 0) ctx.fillStyle = '#ffffffaa';
                            ctx.beginPath();
                            ctx.roundRect(px + 0.05, py + 0.05, 0.9, 0.9, 0.25);
                            ctx.fill();
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                            ctx.beginPath();
                            ctx.ellipse(px + 0.35, py + 0.3, 0.15, 0.1, 0, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                });
            });
        }

        function getGhostPosition() {
            let y = player.pos.y;
            while (!collide(arena, {pos: {x: player.pos.x, y: y + 1}, matrix: player.matrix})) {
                y++;
            }
            return y;
        }

        function lightenColor(hex, percent) {
            const num = parseInt(hex.replace('#', ''), 16),
                amt = Math.round(2.55 * percent),
                R = (num >> 16) + amt, G = (num >> 8 & 0x00FF) + amt, B = (num & 0x0000FF) + amt;
            return "#" + (0x1000000 + (R < 255 ? R < 0 ? 0 : R : 255) * 0x10000 + (G < 255 ? G < 0 ? 0 : G : 255) * 0x100 + (B < 255 ? B < 0 ? 0 : B : 255)).toString(16).slice(1);
        }

        function drawNext() {
            [nextCtx1, nextCtx2].forEach((ctx, i) => {
                ctx.clearRect(0, 0, 4, 4);
                if (player.queue[i]) {
                    const matrix = player.queue[i];
                    const offX = (4 - matrix[0].length) / 2;
                    const offY = (4 - matrix.length) / 2;
                    drawMatrix(ctx, matrix, {x: offX, y: offY});
                }
            });
        }

        function collide(arena, p) {
            const [m, o] = [p.matrix, p.pos];
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) return true;
                }
            }
            return false;
        }

        function useMagic() {
            if (!isStarted || isGameOver || isPaused || player.magicCharges <= 0) return;
            let gaps = [];
            for (let y = arena.length - 1; y >= 0; y--) {
                for (let x = 0; x < arena[y].length; x++) {
                    if (arena[y][x] === 0) {
                        let hasBlockAbove = false;
                        for (let up = y - 1; up >= 0; up--) if (arena[up][x] !== 0) { hasBlockAbove = true; break; }
                        if (hasBlockAbove || y === arena.length - 1) gaps.push({x, y});
                    }
                }
            }
            if (gaps.length === 0) return;
            gaps.sort(() => Math.random() - 0.5);
            const count = Math.min(gaps.length, 7);
            for (let i = 0; i < count; i++) arena[gaps[i].y][gaps[i].x] = 9;
            player.magicCharges--;
            updateMagicDisplay();
            arenaSweep();
        }

        function merge(arena, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) arena[y + player.pos.y][x + player.pos.x] = value;
                });
            });
        }

        function rotate(matrix, dir) {
            for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
            }
            if (dir > 0) matrix.forEach(row => row.reverse()); else matrix.reverse();
        }

        function arenaSweep() {
            let rowCount = 0;
            let tempClearingRows = [];
            outer: for (let y = arena.length - 1; y > 0; --y) {
                for (let x = 0; x < arena[y].length; ++x) if (arena[y][x] === 0) continue outer;
                tempClearingRows.push(y);
                rowCount++;
            }
            if (rowCount > 0) {
                clearingRows = tempClearingRows;
                clearAnimCounter = 10;
                if (rowCount === 4) {
                    tetrisFlashCounter = 30;
                    tetrisEffect.classList.remove('hidden');
                    setTimeout(() => tetrisEffect.classList.add('hidden'), 1500);
                }
                const lineScores = { 1: 10, 2: 30, 3: 60, 4: 100 };
                player.score += lineScores[rowCount] || (rowCount * 10);
                updateScore();
            }
        }

        function finishLineClear() {
            clearingRows.sort((a,b) => a-b).forEach(y => {
                const row = arena.splice(y, 1)[0].fill(0);
                arena.unshift(row);
            });
            clearingRows = [];
        }

        function playerDrop() {
            if (isGameOver || isPaused || !isStarted || clearingRows.length > 0) return;
            player.pos.y++;
            if (collide(arena, player)) {
                player.pos.y--;
                merge(arena, player);
                playerReset();
                arenaSweep();
                updateScore();
            }
            dropCounter = 0;
        }

        function playerMove(dir) {
            if (isGameOver || isPaused || !isStarted || clearingRows.length > 0) return;
            player.pos.x += dir;
            if (collide(arena, player)) { player.pos.x -= dir; return false; }
            return true;
        }

        function playerRotate(dir) {
            if (isGameOver || isPaused || !isStarted || clearingRows.length > 0) return;
            const pos = player.pos.x;
            let offset = 1;
            rotate(player.matrix, dir);
            while (collide(arena, player)) {
                player.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > player.matrix[0].length) { rotate(player.matrix, -dir); player.pos.x = pos; return; }
            }
            player.rotateFlash = 3; 
        }

        function playerReset() {
            const pieces = 'ILJOTSZ';
            while (player.queue.length < 3) player.queue.push(createPiece(pieces[pieces.length * Math.random() | 0]));
            player.matrix = player.queue.shift();
            player.queue.push(createPiece(pieces[pieces.length * Math.random() | 0]));
            player.pos.y = 0;
            player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
            if (collide(arena, player)) endGame();
        }

        function updateScore() { scoreElement.innerText = player.score; }
        function updateMagicDisplay() {
            magicChargesElement.innerText = player.magicCharges;
            btnMagic.disabled = (player.magicCharges <= 0 || !specialToggle.checked);
            document.getElementById('magic-count-box').style.display = specialToggle.checked ? 'block' : 'none';
        }

        function updateTimerDisplay() {
            const mins = Math.floor(timeLeft / 60);
            const secs = timeLeft % 60;
            timerElement.innerText = `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

        function togglePause() {
            if (isGameOver || !isStarted) return;
            isPaused = !isPaused;
            if (isPaused) { pauseScreen.classList.remove('hidden'); clearInterval(timerInterval); }
            else { pauseScreen.classList.add('hidden'); lastTime = performance.now(); startTimer(); requestAnimationFrame(update); }
        }

        function manualEndGame() {
            if (!isStarted) return;
            if (isGameOver) { resetGameToHome(); return; }
            if (!isPaused) togglePause();
            quitConfirm.classList.remove('hidden');
        }

        function confirmQuit() { quitConfirm.classList.add('hidden'); pauseScreen.classList.add('hidden'); endGame(); }
        function cancelQuit() { quitConfirm.classList.add('hidden'); togglePause(); }

        function startTimer() {
            clearInterval(timerInterval);
            timerInterval = setInterval(() => { if (timeLeft > 0) { timeLeft--; updateTimerDisplay(); } else { endGame(); } }, 1000);
        }

        function endGame() {
            isGameOver = true;
            clearInterval(timerInterval);
            finalScoreElement.innerText = player.score;
            gameOverScreen.classList.remove('hidden');
            draw();
        }

        function startGame() {
            isStarted = true;
            startScreen.classList.add('hidden');
            player.magicCharges = specialToggle.checked ? 3 : 0;
            btnMagic.style.display = specialToggle.checked ? 'flex' : 'none';
            updateMagicDisplay();
            playerReset();
            lastTime = performance.now();
            startTimer();
            requestAnimationFrame(update);
        }

        let dropCounter = 0, dropInterval = 1000, lastTime = 0, timeLeft = 180, timerInterval = null;

        function update(time = 0) {
            if (isGameOver || isPaused || !isStarted) return;
            const deltaTime = time - lastTime;
            lastTime = time;
            if (isLeftActive || isRightActive) {
                moveTimer += deltaTime;
                if (moveTimer > MOVE_DELAY) { if (moveTimer > MOVE_DELAY + MOVE_INTERVAL) { playerMove(isLeftActive ? -1 : 1); moveTimer = MOVE_DELAY; } }
            } else moveTimer = 0;

            if (clearingRows.length > 0) {
                clearAnimCounter--; if (clearAnimCounter <= 0) finishLineClear();
            } else {
                dropCounter += deltaTime;
                const currentInterval = isDownActive ? dropInterval / 8 : dropInterval;
                if (dropCounter > currentInterval) playerDrop();
            }
            draw(); requestAnimationFrame(update);
        }

        function resetGameToHome() {
            arena.forEach(row => row.fill(0));
            player.score = 0; player.queue = []; player.magicCharges = 3; timeLeft = 180;
            isGameOver = false; isPaused = false; isStarted = false; isDownActive = false; isLeftActive = false; isRightActive = false;
            clearingRows = []; gameOverScreen.classList.add('hidden'); pauseScreen.classList.add('hidden');
            quitConfirm.classList.add('hidden'); startScreen.classList.remove('hidden');
            updateTimerDisplay(); updateScore(); updateMagicDisplay(); clearInterval(timerInterval); draw();
        }

        document.addEventListener('keydown', event => {
            if ([32, 37, 38, 39, 40].includes(event.keyCode)) event.preventDefault();
            if (isGameOver || !isStarted || isPaused || clearingRows.length > 0) return;
            if (event.keyCode === 37) { if (!isLeftActive) { playerMove(-1); isLeftActive = true; moveTimer = 0; } }
            else if (event.keyCode === 39) { if (!isRightActive) { playerMove(1); isRightActive = true; moveTimer = 0; } }
            else if (event.keyCode === 40) isDownActive = true;
            else if (event.keyCode === 32) playerRotate(1);
        });
        document.addEventListener('keyup', event => {
            if (event.keyCode === 37) isLeftActive = false;
            if (event.keyCode === 39) isRightActive = false;
            if (event.keyCode === 40) isDownActive = false;
        });

        const setupMoveBtn = (id, dir) => {
            const btn = document.getElementById(id);
            const start = (e) => { e.preventDefault(); if (dir === -1) { isLeftActive = true; isRightActive = false; } else { isRightActive = true; isLeftActive = false; } playerMove(dir); moveTimer = 0; };
            const stop = (e) => { e.preventDefault(); if (dir === -1) isLeftActive = false; else isRightActive = false; };
            btn.addEventListener('touchstart', start, {passive: false}); btn.addEventListener('mousedown', start);
            btn.addEventListener('touchend', stop); btn.addEventListener('mouseup', stop); btn.addEventListener('mouseleave', stop);
        };
        const setupSimpleBtn = (id, onDown, onUp) => {
            const btn = document.getElementById(id);
            const start = (e) => { e.preventDefault(); onDown(); };
            btn.addEventListener('touchstart', start, {passive: false}); btn.addEventListener('mousedown', start);
            if (onUp) { const stop = (e) => { e.preventDefault(); onUp(); }; btn.addEventListener('touchend', stop); btn.addEventListener('mouseup', stop); btn.addEventListener('mouseleave', stop); }
        };

        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); if (isStarted && !isPaused && !isGameOver) playerRotate(1); }, {passive: false});
        canvas.addEventListener('mousedown', (e) => { e.preventDefault(); if (isStarted && !isPaused && !isGameOver) playerRotate(1); });

        setupMoveBtn('btn-left', -1); setupMoveBtn('btn-right', 1);
        setupSimpleBtn('btn-down', () => isDownActive = true, () => isDownActive = false);
        setupSimpleBtn('btn-rotate', () => playerRotate(1));
        setupSimpleBtn('btn-magic', () => useMagic());

        function resetGame() { resetGameToHome(); startGame(); }
        updateScore(); updateTimerDisplay(); updateMagicDisplay(); draw();
    </script>
</body>
</html>
