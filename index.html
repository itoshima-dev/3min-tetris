<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>„ÉÜ„Éà„É™„Çπ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #eaffd0;
            --btn-shadow: rgba(0, 0, 0, 0.15);
        }
        body {
            touch-action: none;
            background-color: var(--bg-color);
            background-image: 
                radial-gradient(rgba(255, 255, 255, 0.7) 20%, transparent 20%),
                radial-gradient(rgba(255, 255, 255, 0.7) 20%, transparent 20%);
            background-size: 50px 50px;
            background-position: 0 0, 25px 25px;
            color: #4a4a4a;
            font-family: 'Zen Maru Gothic', sans-serif;
            overflow: hidden; 
            height: 100dvh;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .game-console {
            display: flex;
            flex-direction: column;
            width: 95%;
            height: 96%;
            max-width: 460px;
            max-height: 820px;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border: 8px solid #fff;
            border-radius: 40px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.05);
            padding: 15px;
            box-sizing: border-box;
            position: relative;
        }

        .header { flex-shrink: 0; margin-bottom: 12px; }

        .main-display {
            flex-grow: 1;
            display: flex;
            gap: 10px;
            min-height: 0;
            justify-content: center;
            align-items: center;
        }

        .canvas-wrapper {
            position: relative;
            height: 100%;
            aspect-ratio: 10 / 18;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 15px;
            overflow: hidden;
            border: 4px solid #fff;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.02);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #game-canvas { width: 100%; height: 100%; display: block; }

        .side-panel {
            width: 75px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex-shrink: 0;
        }

        .side-item {
            background: white;
            border: 2px solid #f0f0f0;
            border-radius: 15px;
            padding: 5px;
            text-align: center;
        }

        /* „Ç∑„É≥„Éó„É´„ÅßÊ∏ÖÊΩîÊÑü„ÅÆ„ÅÇ„Çã„Éú„Çø„É≥„Éá„Ç∂„Ç§„É≥ */
        .btn-pop {
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            transition: transform 0.05s, box-shadow 0.05s;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border-radius: 16px;
            box-shadow: 0 4px 0 var(--btn-shadow);
        }

        .btn-pop:active {
            transform: translateY(3px);
            box-shadow: 0 1px 0 var(--btn-shadow);
        }

        /* „Ç´„É©„Éº„ÅØÂçòËâ≤„Åß„Çπ„ÉÉ„Ç≠„É™ */
        .color-green  { background-color: #76c760; color: white; }
        .color-yellow { background-color: #fdd835; color: #5d4037; }
        .color-blue   { background-color: #4fc3f7; color: white; }
        .color-red    { background-color: #ff5252; color: white; }
        .color-magic  { background-color: #ba68c8; color: white; }

        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.96);
            backdrop-filter: blur(8px);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }

        .input-panel { flex-shrink: 0; margin-top: 15px; padding-bottom: 5px; }

        .text-pop { animation: tetrisPop 1.5s ease-out forwards; }
        @keyframes tetrisPop {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }

        .switch {
            position: relative; display: inline-block; width: 40px; height: 22px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #eee; transition: .4s; border-radius: 22px;
        }
        .slider:before {
            position: absolute; content: ""; height: 16px; width: 16px;
            left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%;
        }
        input:checked + .slider { background-color: #76c760; }
        input:checked + .slider:before { transform: translateX(18px); }
    </style>
</head>
<body>

    <div class="game-console">
        
        <div class="header">
            <div class="bg-white border-2 border-gray-100 rounded-full py-2 px-6 flex items-center justify-center gap-4 shadow-sm">
                <span class="text-xs font-bold text-gray-400">„ÅÆ„Åì„ÇäÊôÇÈñì</span>
                <span id="timer" class="text-3xl font-mono text-red-400 leading-none">03:00</span>
            </div>
        </div>

        <div class="main-display">
            <div class="canvas-wrapper">
                <canvas id="game-canvas" width="200" height="360"></canvas>
                
                <div id="tetris-effect" class="hidden absolute inset-0 flex items-center justify-center pointer-events-none z-30">
                    <span class="text-pop text-4xl font-black text-pink-400 drop-shadow-[0_0_10px_white] italic text-center">‚ú®„Éë„Éº„Éï„Çß„ÇØ„Éà‚ú®</span>
                </div>

                <!-- „Çπ„Çø„Éº„ÉàÁîªÈù¢ -->
                <div id="start-screen" class="overlay">
                    <div class="w-full mb-6 space-y-4">
                        <div class="bg-gray-50 rounded-2xl p-4 border border-gray-100 shadow-sm text-center">
                            <p class="text-xs font-bold text-gray-500 mb-3 uppercase tracking-wider">Score List</p>
                            <div class="grid grid-cols-2 gap-2 text-[11px]">
                                <div class="bg-white rounded-lg py-1.5 px-3 flex justify-between border border-gray-100"><span>1Âàó</span><b class="text-pink-400">10ÁÇπ</b></div>
                                <div class="bg-white rounded-lg py-1.5 px-3 flex justify-between border border-gray-100"><span>3Âàó</span><b class="text-blue-400">60ÁÇπ</b></div>
                                <div class="bg-white rounded-lg py-1.5 px-3 flex justify-between border border-gray-100"><span>2Âàó</span><b class="text-orange-400">30ÁÇπ</b></div>
                                <div class="bg-white rounded-lg py-1.5 px-3 flex justify-between border border-yellow-500 font-bold"><span>4Âàó</span><b>100ÁÇπ</b></div>
                            </div>
                        </div>
                        <div class="bg-purple-50 rounded-2xl p-3 border border-purple-100 text-center">
                            <p class="text-[13px] font-bold text-purple-400 mb-1">ü™Ñ „Åæ„Åª„ÅÜ„ÅÆ„Éú„Çø„É≥</p>
                            <p class="text-[10px] text-gray-500 leading-tight">ËôπËâ≤„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„Åß „Åô„Åç„Åæ„Çí„ÅÜ„ÇÅ„Çã„ÇàÔºÅ</p>
                        </div>
                        <div class="flex items-center justify-between px-4 py-2 bg-white rounded-2xl border border-gray-100">
                            <span class="text-xs font-bold text-gray-400">„Åæ„Åª„ÅÜ„Çí‰Ωø„ÅÜ</span>
                            <label class="switch">
                                <input type="checkbox" id="special-toggle" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    <button onclick="startGame()" class="btn-pop color-green rounded-full px-12 py-3.5 text-xl whitespace-nowrap">
                        „Çπ„Çø„Éº„ÉàÔºÅ
                    </button>
                </div>

                <!-- „Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºÁîªÈù¢ -->
                <div id="game-over" class="hidden overlay">
                    <h2 class="text-2xl font-bold text-gray-700 mb-4">„Åä„Åó„Åæ„ÅÑ„Å£üß∏</h2>
                    <p class="text-sm text-gray-400 mb-1">‰ªäÂõû„ÅÆ„Çπ„Ç≥„Ç¢</p>
                    <p class="text-6xl font-mono font-bold text-green-400 mb-10"><span id="final-score">0</span><span class="text-2xl ml-1">ÁÇπ</span></p>
                    <button onclick="resetGame()" class="btn-pop color-green rounded-full px-10 py-3.5 text-lg">„ÇÇ„ÅÜ„ÅÑ„Å°„Å©ÔºÅ</button>
                </div>

                <!-- „Éù„Éº„Ç∫ÁîªÈù¢ -->
                <div id="pause-screen" class="hidden overlay">
                    <h2 class="text-3xl font-bold text-gray-400 mb-12 text-center">„Åä„ÇÑ„Åô„Åø‰∏≠...üí§</h2>
                    <button onclick="togglePause()" class="btn-pop color-blue rounded-full px-12 py-3.5 text-xl">„Å§„Å•„Åç„Åã„Çâ</button>
                </div>

                <!-- ÁµÇ‰∫ÜÁ¢∫Ë™ç -->
                <div id="quit-confirm" class="hidden overlay">
                    <h2 class="text-2xl font-bold text-red-400 mb-8">„Åä„Çè„Çä„Å´„Åó„Åæ„Åô„ÅãÔºü</h2>
                    <div class="flex flex-col gap-4 w-full px-6">
                        <button onclick="confirmQuit()" class="btn-pop color-red rounded-xl py-3.5 text-lg">„Åä„Çè„Çã</button>
                        <button onclick="cancelQuit()" class="btn-pop color-green rounded-xl py-3.5 text-lg">„Å§„Å•„Åë„Çã</button>
                    </div>
                </div>
            </div>

            <!-- Âè≥„Çµ„Ç§„Éâ„Éê„Éº -->
            <div class="side-panel">
                <div class="side-item">
                    <p class="text-[9px] font-bold text-gray-400 mb-1">„Çπ„Ç≥„Ç¢</p>
                    <p class="text-lg font-mono font-bold text-green-400 leading-none"><span id="score">0</span></p>
                    <p class="text-[8px] text-gray-400">ÁÇπ</p>
                </div>
                <div id="magic-count-box" class="side-item border-purple-100">
                    <p class="text-[9px] font-bold text-purple-300 mb-1">„Åæ„Åª„ÅÜ</p>
                    <p id="magic-charges" class="text-xl font-bold text-purple-400 leading-none">3</p>
                </div>
                <div class="side-item">
                    <p class="text-[9px] font-bold text-gray-300 mb-1">„Å§„Åé</p>
                    <canvas id="next-1" width="50" height="50"></canvas>
                </div>
                <div class="side-item">
                    <p class="text-[9px] font-bold text-gray-300 mb-1">„Åù„ÅÆ„Å§„Åé</p>
                    <canvas id="next-2" width="50" height="50"></canvas>
                </div>
            </div>
        </div>

        <!-- 3. Êìç‰Ωú„Éë„Éç„É´ -->
        <div class="input-panel">
            <div class="flex flex-col items-center gap-4">
                <div class="flex gap-10 items-center">
                    <button id="btn-rotate" class="btn-pop color-yellow w-12 h-12 rounded-full text-2xl">‚Üª</button>
                    <button id="btn-pause" onclick="togglePause()" class="btn-pop color-blue w-12 h-12 rounded-full text-lg">‚è∏</button>
                    <button id="btn-quit" onclick="manualEndGame()" class="btn-pop color-red w-12 h-12 rounded-full text-lg">‚èπ</button>
                </div>
                
                <div class="grid grid-cols-4 gap-3 w-full max-w-[360px]">
                    <button id="btn-left" class="btn-pop color-green h-14 rounded-2xl text-3xl">‚Üê</button>
                    <button id="btn-down" class="btn-pop color-green h-14 rounded-2xl text-3xl">‚Üì</button>
                    <button id="btn-right" class="btn-pop color-green h-14 rounded-2xl text-3xl">‚Üí</button>
                    <button id="btn-magic" class="btn-pop color-magic h-14 rounded-2xl flex flex-col items-center justify-center">
                        <span class="text-xl leading-none">ü™Ñ</span>
                        <span class="text-[9px] font-bold">„Åæ„Åª„ÅÜ</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const context = canvas.getContext('2d');
        const nextCtx1 = document.getElementById('next-1').getContext('2d');
        const nextCtx2 = document.getElementById('next-2').getContext('2d');
        const scoreElement = document.getElementById('score');
        const timerElement = document.getElementById('timer');
        const magicChargesElement = document.getElementById('magic-charges');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over');
        const pauseScreen = document.getElementById('pause-screen');
        const quitConfirm = document.getElementById('quit-confirm');
        const finalScoreElement = document.getElementById('final-score');
        const specialToggle = document.getElementById('special-toggle');
        const btnMagic = document.getElementById('btn-magic');
        const tetrisEffect = document.getElementById('tetris-effect');

        const GRID_SIZE = 20; 
        context.scale(GRID_SIZE, GRID_SIZE);
        nextCtx1.scale(10, 10);
        nextCtx2.scale(10, 10);

        const colors = [
            null,
            '#ff5e78', // I
            '#ff9642', // L
            '#3ddad7', // J
            '#ffdf40', // O
            '#55e055', // Z
            '#ff85e4', // S
            '#6a9dff', // T
            '#ffffff', // È≠îÊ≥ï
        ];

        function createPiece(type) {
            if (type === 'I') return [[0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]];
            if (type === 'L') return [[0, 2, 0], [0, 2, 0], [0, 2, 2]];
            if (type === 'J') return [[0, 3, 0], [0, 3, 0], [3, 3, 0]];
            if (type === 'O') return [[4, 4], [4, 4]];
            if (type === 'Z') return [[5, 5, 0], [0, 5, 5], [0, 0, 0]];
            if (type === 'S') return [[0, 6, 6], [6, 6, 0], [0, 0, 0]];
            if (type === 'T') return [[0, 7, 0], [7, 7, 7], [0, 0, 0]];
        }

        const arena = Array.from({length: 18}, () => new Array(10).fill(0));
        const player = { pos: {x: 0, y: 0}, matrix: null, score: 0, queue: [], magicCharges: 3, rotateFlash: 0 };

        let clearingRows = [], clearAnimCounter = 0, tetrisFlashCounter = 0, globalTick = 0;
        let isStarted = false, isGameOver = false, isPaused = false;
        let isLeftActive = false, isRightActive = false, isDownActive = false, moveTimer = 0;
        const MOVE_DELAY = 180, MOVE_INTERVAL = 60; 

        function draw() {
            globalTick++;
            context.clearRect(0, 0, 10, 18);
            context.fillStyle = 'rgba(255, 255, 255, 0.4)';
            context.fillRect(0, 0, 10, 18);
            
            if (tetrisFlashCounter > 0) {
                tetrisFlashCounter--;
                context.fillStyle = `hsla(${(globalTick * 20) % 360}, 100%, 80%, 0.4)`;
                context.fillRect(0, 0, 10, 18);
            }

            drawMatrix(context, arena, {x: 0, y: 0});
            if (player.matrix && isStarted && !isPaused && !isGameOver) {
                drawMatrix(context, player.matrix, {x: player.pos.x, y: getGhostPosition()}, true);
            }
            drawMatrix(context, player.matrix, player.pos);
            
            if (clearingRows.length > 0) {
                context.fillStyle = `rgba(255, 255, 255, ${clearAnimCounter / 10})`;
                clearingRows.forEach(y => context.fillRect(0, y, 10, 1));
            }
            drawNext();
            if (player.rotateFlash > 0) player.rotateFlash--;
        }

        function drawMatrix(ctx, matrix, offset, isGhost = false) {
            if (!matrix) return;
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        const px = x + offset.x, py = y + offset.y;
                        if (isGhost) {
                            ctx.strokeStyle = colors[value];
                            ctx.lineWidth = 0.05;
                            ctx.setLineDash([0.2, 0.1]);
                            ctx.strokeRect(px + 0.1, py + 0.1, 0.8, 0.8);
                            ctx.setLineDash([]);
                            ctx.fillStyle = colors[value] + '22';
                            ctx.fillRect(px + 0.1, py + 0.1, 0.8, 0.8);
                            return;
                        }
                        if (value === 9) {
                            const hue = (globalTick * 8 + px * 30 + py * 30) % 360;
                            ctx.fillStyle = `hsla(${hue}, 90%, 75%, 1)`;
                            ctx.beginPath(); ctx.roundRect(px + 0.05, py + 0.05, 0.9, 0.9, 0.4); ctx.fill();
                            ctx.fillStyle = 'white';
                            if (Math.sin(globalTick * 0.3 + px) > 0) {
                                ctx.fillRect(px + 0.1, py + 0.1, 0.15, 0.15); ctx.fillRect(px + 0.7, py + 0.7, 0.15, 0.15);
                            }
                            ctx.strokeStyle = 'white'; ctx.lineWidth = 0.05; ctx.stroke();
                        } else {
                            const grad = ctx.createRadialGradient(px+0.5, py+0.5, 0.1, px+0.5, py+0.5, 0.6);
                            grad.addColorStop(0, colors[value]);
                            grad.addColorStop(1, lightenColor(colors[value], 20));
                            ctx.fillStyle = (!isGhost && player.rotateFlash > 0) ? '#ffffffaa' : grad;
                            ctx.beginPath(); ctx.roundRect(px + 0.05, py + 0.05, 0.9, 0.9, 0.25); ctx.fill();
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                            ctx.beginPath(); ctx.ellipse(px + 0.35, py + 0.3, 0.15, 0.1, 0, 0, Math.PI * 2); ctx.fill();
                        }
                    }
                });
            });
        }

        function getGhostPosition() {
            let y = player.pos.y;
            while (!collide(arena, {pos: {x: player.pos.x, y: y + 1}, matrix: player.matrix})) y++;
            return y;
        }

        function lightenColor(hex, percent) {
            const num = parseInt(hex.replace('#', ''), 16), amt = Math.round(2.55 * percent),
                R = (num >> 16) + amt, G = (num >> 8 & 0x00FF) + amt, B = (num & 0x0000FF) + amt;
            return "#" + (0x1000000 + (R < 255 ? R < 0 ? 0 : R : 255) * 0x10000 + (G < 255 ? G < 0 ? 0 : G : 255) * 0x100 + (B < 255 ? B < 0 ? 0 : B : 255)).toString(16).slice(1);
        }

        function drawNext() {
            [nextCtx1, nextCtx2].forEach((ctx, i) => {
                ctx.clearRect(0, 0, 5, 5);
                if (player.queue[i]) {
                    const matrix = player.queue[i];
                    drawMatrix(ctx, matrix, {x: (5 - matrix[0].length) / 2, y: (5 - matrix.length) / 2});
                }
            });
        }

        function collide(arena, p) {
            const [m, o] = [p.matrix, p.pos];
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) return true;
                }
            }
            return false;
        }

        function useMagic() {
            if (!isStarted || isGameOver || isPaused || player.magicCharges <= 0) return;
            let gaps = [];
            for (let y = arena.length - 1; y >= 0; y--) {
                for (let x = 0; x < arena[y].length; x++) {
                    if (arena[y][x] === 0) {
                        let hasBlockAbove = false;
                        for (let up = y - 1; up >= 0; up--) if (arena[up][x] !== 0) { hasBlockAbove = true; break; }
                        if (hasBlockAbove || y === arena.length - 1) gaps.push({x, y});
                    }
                }
            }
            if (gaps.length === 0) return;
            gaps.sort(() => Math.random() - 0.5);
            const count = Math.min(gaps.length, 7);
            for (let i = 0; i < count; i++) arena[gaps[i].y][gaps[i].x] = 9;
            player.magicCharges--;
            updateMagicDisplay();
            arenaSweep();
        }

        function merge(arena, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) arena[y + player.pos.y][x + player.pos.x] = value;
                });
            });
        }

        function rotate(matrix, dir) {
            for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
            }
            if (dir > 0) matrix.forEach(row => row.reverse()); else matrix.reverse();
        }

        function arenaSweep() {
            let rowCount = 0;
            let tempClearingRows = [];
            outer: for (let y = arena.length - 1; y > 0; --y) {
                for (let x = 0; x < arena[y].length; ++x) if (arena[y][x] === 0) continue outer;
                tempClearingRows.push(y);
                rowCount++;
            }
            if (rowCount > 0) {
                clearingRows = tempClearingRows;
                clearAnimCounter = 10;
                if (rowCount === 4) {
                    tetrisFlashCounter = 30;
                    tetrisEffect.classList.remove('hidden');
                    setTimeout(() => tetrisEffect.classList.add('hidden'), 1500);
                }
                const lineScores = { 1: 10, 2: 30, 3: 60, 4: 100 };
                player.score += lineScores[rowCount] || (rowCount * 10);
                updateScore();
            }
        }

        function finishLineClear() {
            clearingRows.sort((a,b) => a-b).forEach(y => {
                const row = arena.splice(y, 1)[0].fill(0);
                arena.unshift(row);
            });
            clearingRows = [];
        }

        function playerDrop() {
            if (isGameOver || isPaused || !isStarted || clearingRows.length > 0) return;
            player.pos.y++;
            if (collide(arena, player)) {
                player.pos.y--;
                merge(arena, player);
                playerReset();
                arenaSweep();
                updateScore();
            }
            dropCounter = 0;
        }

        function playerMove(dir) {
            if (isGameOver || isPaused || !isStarted || clearingRows.length > 0) return;
            player.pos.x += dir;
            if (collide(arena, player)) { player.pos.x -= dir; return false; }
            return true;
        }

        function playerRotate(dir) {
            if (isGameOver || isPaused || !isStarted || clearingRows.length > 0) return;
            const pos = player.pos.x;
            let offset = 1;
            rotate(player.matrix, dir);
            while (collide(arena, player)) {
                player.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > player.matrix[0].length) { rotate(player.matrix, -dir); player.pos.x = pos; return; }
            }
            player.rotateFlash = 3; 
        }

        function playerReset() {
            const pieces = 'ILJOTSZ';
            while (player.queue.length < 3) player.queue.push(createPiece(pieces[pieces.length * Math.random() | 0]));
            player.matrix = player.queue.shift();
            player.queue.push(createPiece(pieces[pieces.length * Math.random() | 0]));
            player.pos.y = 0;
            player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
            if (collide(arena, player)) endGame();
        }

        function updateScore() { scoreElement.innerText = player.score; }
        function updateMagicDisplay() {
            magicChargesElement.innerText = player.magicCharges;
            btnMagic.disabled = (player.magicCharges <= 0 || !specialToggle.checked);
            document.getElementById('magic-count-box').style.display = specialToggle.checked ? 'block' : 'none';
        }

        function updateTimerDisplay() {
            const mins = Math.floor(timeLeft / 60);
            const secs = timeLeft % 60;
            timerElement.innerText = `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

        function togglePause() {
            if (isGameOver || !isStarted) return;
            isPaused = !isPaused;
            if (isPaused) { pauseScreen.classList.remove('hidden'); clearInterval(timerInterval); }
            else { pauseScreen.classList.add('hidden'); lastTime = performance.now(); startTimer(); requestAnimationFrame(update); }
        }

        function manualEndGame() {
            if (!isStarted) return;
            if (isGameOver) { resetGameToHome(); return; }
            if (!isPaused) togglePause();
            quitConfirm.classList.remove('hidden');
        }

        function confirmQuit() { quitConfirm.classList.add('hidden'); pauseScreen.classList.add('hidden'); endGame(); }
        function cancelQuit() { quitConfirm.classList.add('hidden'); togglePause(); }

        function startTimer() {
            clearInterval(timerInterval);
            timerInterval = setInterval(() => { if (timeLeft > 0) { timeLeft--; updateTimerDisplay(); } else { endGame(); } }, 1000);
        }

        function endGame() {
            isGameOver = true;
            clearInterval(timerInterval);
            finalScoreElement.innerText = player.score;
            gameOverScreen.classList.remove('hidden');
            draw();
        }

        function startGame() {
            isStarted = true;
            startScreen.classList.add('hidden');
            player.magicCharges = specialToggle.checked ? 3 : 0;
            btnMagic.style.display = specialToggle.checked ? 'flex' : 'none';
            updateMagicDisplay();
            playerReset();
            lastTime = performance.now();
            startTimer();
            requestAnimationFrame(update);
        }

        let dropCounter = 0, dropInterval = 1000, lastTime = 0, timeLeft = 180, timerInterval = null;

        function update(time = 0) {
            if (isGameOver || isPaused || !isStarted) return;
            const deltaTime = time - lastTime;
            lastTime = time;
            if (isLeftActive || isRightActive) {
                moveTimer += deltaTime;
                if (moveTimer > MOVE_DELAY) { if (moveTimer > MOVE_DELAY + MOVE_INTERVAL) { playerMove(isLeftActive ? -1 : 1); moveTimer = MOVE_DELAY; } }
            } else moveTimer = 0;

            if (clearingRows.length > 0) {
                clearAnimCounter--; if (clearAnimCounter <= 0) finishLineClear();
            } else {
                dropCounter += deltaTime;
                const currentInterval = isDownActive ? dropInterval / 8 : dropInterval;
                if (dropCounter > currentInterval) playerDrop();
            }
            draw(); requestAnimationFrame(update);
        }

        function resetGameToHome() {
            arena.forEach(row => row.fill(0));
            player.score = 0; player.queue = []; player.magicCharges = 3; timeLeft = 180;
            isGameOver = false; isPaused = false; isStarted = false; isDownActive = false; isLeftActive = false; isRightActive = false;
            clearingRows = []; gameOverScreen.classList.add('hidden'); pauseScreen.classList.add('hidden');
            quitConfirm.classList.add('hidden'); startScreen.classList.remove('hidden');
            updateTimerDisplay(); updateScore(); updateMagicDisplay(); clearInterval(timerInterval); draw();
        }

        document.addEventListener('keydown', event => {
            if ([32, 37, 38, 39, 40].includes(event.keyCode)) event.preventDefault();
            if (isGameOver || !isStarted || isPaused || clearingRows.length > 0) return;
            if (event.keyCode === 37) { if (!isLeftActive) { playerMove(-1); isLeftActive = true; moveTimer = 0; } }
            else if (event.keyCode === 39) { if (!isRightActive) { playerMove(1); isRightActive = true; moveTimer = 0; } }
            else if (event.keyCode === 40) isDownActive = true;
            else if (event.keyCode === 32) playerRotate(1);
        });
        document.addEventListener('keyup', event => {
            if (event.keyCode === 37) isLeftActive = false;
            if (event.keyCode === 39) isRightActive = false;
            if (event.keyCode === 40) isDownActive = false;
        });

        const setupMoveBtn = (id, dir) => {
            const btn = document.getElementById(id);
            const start = (e) => { e.preventDefault(); if (dir === -1) { isLeftActive = true; isRightActive = false; } else { isRightActive = true; isLeftActive = false; } playerMove(dir); moveTimer = 0; };
            const stop = (e) => { e.preventDefault(); if (dir === -1) isLeftActive = false; else isRightActive = false; };
            btn.addEventListener('touchstart', start, {passive: false}); btn.addEventListener('mousedown', start);
            btn.addEventListener('touchend', stop); btn.addEventListener('mouseup', stop); btn.addEventListener('mouseleave', stop);
        };
        const setupSimpleBtn = (id, onDown, onUp) => {
            const btn = document.getElementById(id);
            const start = (e) => { e.preventDefault(); onDown(); };
            btn.addEventListener('touchstart', start, {passive: false}); btn.addEventListener('mousedown', start);
            if (onUp) { const stop = (e) => { e.preventDefault(); onUp(); }; btn.addEventListener('touchend', stop); btn.addEventListener('mouseup', stop); btn.addEventListener('mouseleave', stop); }
        };

        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); if (isStarted && !isPaused && !isGameOver) playerRotate(1); }, {passive: false});
        canvas.addEventListener('mousedown', (e) => { e.preventDefault(); if (isStarted && !isPaused && !isGameOver) playerRotate(1); });

        setupMoveBtn('btn-left', -1); setupMoveBtn('btn-right', 1);
        setupSimpleBtn('btn-down', () => isDownActive = true, () => isDownActive = false);
        setupSimpleBtn('btn-rotate', () => playerRotate(1));
        setupSimpleBtn('btn-magic', () => useMagic());

        function resetGame() { resetGameToHome(); startGame(); }
        updateScore(); updateTimerDisplay(); updateMagicDisplay(); draw();
    </script>
</body>
</html>
